#图论笔记
##1.图论基础
###1.1 树和图
+ 树是一种无环图（√）
+ 无环图一定是树（×）
    + 无环图不一定是树，因为可能存在着大于1的连通分量
+ 连通分量为1的无环图一定是树（√）
+ 一个图一定有生成树（×）
    + 一个图可能连通分量不为1，对于每个连通分量为1的图，一定有生成树
+ 一个图一定有生成森林（√）
### 1.2 无向图的度
对于无向图来说，度就是这个顶点相邻的边数
### 1.3 图（无向无权图）的表示
+ 以下代码的构造函数中，通过解析文件的方式进行图的构建
+ 文件内容示例
  ````
  7 9
  0 1
  0 3
  1 2
  1 6
  2 3
  2 5
  3 4
  4 5
  5 6
  ````
    + 其中，第一行的两个数字分别表示顶点个数以及边的数量
        + 如第一行[7 9]表示这个图有7个顶点，9条边
    + 余下的行表示具体的边
        + 如[0 1]表示顶点0与顶点1存在一条边
+ 邻接矩阵
    + 对于简单图，因为没有自环边，所以主对角线上的值均为0
    + 矩阵中的元素，不一定要为0或者1，也可以通过其他的数字来方便的表示平行边的存在
    + 对于无向图来说，邻接矩阵关于主对角线对称
    + 空间复杂度
        + O(V^2)[存在优化空间]
    + 时间复杂度
        + 建图：O(E)[没有优化空间]
        + 查看两点是否相邻：O(1)[没有优化空间]
        + 求一个点的相邻节点：O(V)[存在优化空间]
    ````
  public class AdjMatrix {
  
      private int V;
      private int E;
      private int[][] adj;
  
      public AdjMatrix(String fileName) {
          File file = new File(fileName);
          try {
              Scanner scanner = new Scanner(file);
              V = scanner.nextInt();
              if (V < 0) {
                  throw new IllegalArgumentException("V must be non-negative");
              }
              adj = new int[V][V];
              E = scanner.nextInt();
              if (E < 0) {
                  throw new IllegalArgumentException("E must be non-negative");
              }
              for (int i = 0; i < E; i++) {
                  int a = scanner.nextInt();
                  validateVertex(a);
                  int b = scanner.nextInt();
                  validateVertex(b);
                  if (a == b) {
                      throw new IllegalArgumentException("Self loop is Detected");
                  }
                  if (adj[a][b] == 1) {
                      throw new IllegalArgumentException("Parallel Edges is Detected");
                  }
                  adj[a][b] = 1;
                  adj[b][a] = 1;
              }
          } catch (FileNotFoundException e) {
              e.printStackTrace();
          }
      }
  
      private void validateVertex(int v) {
          if (v < 0 || v >= V) {
              throw new IllegalArgumentException("vertex" + v + "is invalid");
          }
      }
  
      public int V() {
          return V;
      }
  
      public int E() {
          return E;
      }
  
      //获取与传入顶点邻接的所有顶点
      public ArrayList<Integer> adj(int v) {
          validateVertex(v);
          ArrayList<Integer> res = new ArrayList<>();
          for (int i = 0; i < V; i++) {
              if (adj[V][i] == 1) {
                  res.add(i);
              }
          }
          return res;
      }
  
      //获取传入顶点的度
      public int degree(int v) {
          return adj(v).size();
      }
  
      public boolean hasEdge(int v, int w) {
          validateVertex(v);
          validateVertex(w);
          return adj[v][w] == 1;
      }
  
      @Override
      public String toString() {
          StringBuilder sb = new StringBuilder();
          sb.append(String.format("V = %d, E = %d\n", V, E));
          for (int i = 0; i < V; i++) {
              for (int j = 0; j < V; j++) {
                  sb.append(String.format("%d ", adj[i][j]));
              }
              sb.append("\n");
          }
          return sb.toString();
      }
  
  }
    ````
+ 邻接表
    + 相较于邻接矩阵，所需的空间较少
    + 求一个点的相邻节点的时间复杂度相对较低
    + 空间复杂度
        + O(V + E)
    + 时间复杂度
        + 建图：O(V*E)[存在优化空间]
        + 查看两点是否相邻：O(degree(V))[存在优化空间]
        + 求一个点的相邻节点：O(degree(V))
    ````
  public class AdjList {
  
      private int V;
      private int E;
      private LinkedList<Integer>[] adj;
  
      public AdjList(String fileName) {
          File file = new File(fileName);
          try {
              Scanner scanner = new Scanner(file);
              V = scanner.nextInt();
              if (V < 0) {
                  throw new IllegalArgumentException("V must be non-negative");
              }
              adj = new LinkedList[V];
              for (int i = 0; i < V; i++) {
                  adj[i] = new LinkedList<Integer>();
              }
              E = scanner.nextInt();
              if (E < 0) {
                  throw new IllegalArgumentException("E must be non-negative");
              }
              for (int i = 0; i < E; i++) {
                  int a = scanner.nextInt();
                  validateVertex(a);
                  int b = scanner.nextInt();
                  validateVertex(b);
                  if (a == b) {
                      throw new IllegalArgumentException("Self loop is Detected");
                  }
                  if (adj[a].contains(b)) {
                      throw new IllegalArgumentException("Parallel Edges is Detected");
                  }
                  adj[a].add(b);
                  adj[b].add(a);
              }
          } catch (FileNotFoundException e) {
              e.printStackTrace();
          }
      }
  
      private void validateVertex(int v) {
          if (v < 0 || v >= V) {
              throw new IllegalArgumentException("vertex" + v + "is invalid");
          }
      }
  
      public int V() {
          return V;
      }
  
      public int E() {
          return E;
      }
  
      //获取与传入顶点邻接的所有顶点
      public LinkedList<Integer> adj(int v) {
          validateVertex(v);
          return adj[v];
      }
  
      //获取传入顶点的度
      public int degree(int v) {
          return adj(v).size();
      }
  
      public boolean hasEdge(int v, int w) {
          validateVertex(v);
          validateVertex(w);
          return adj[v].contains(w);
      }
  
      @Override
      public String toString() {
          StringBuilder sb = new StringBuilder();
          sb.append(String.format("V = %d, E = %d\n", V, E));
          for (int v = 0; v < V; v++) {
              sb.append(String.format("%d: ", v));
              for (int w : adj[v]) {
                  sb.append(String.format("%d ", w));
              }
              sb.append("\n");
          }
          return sb.toString();
      }
  
  }

    ````
+ 邻接表的优化
    + 上述邻接表实现在[建图]以及[查看两点是否相邻]存在性能瓶颈
    + 优化方式
        + 不使用链表(LinkedList)
        + 使用哈希表(HashSet)[O(1)]
        + 使用红黑树(TreeSet)[O(logV)]
    + 使用红黑树还是哈希表？
        + 使用哈希表进行性能优化在大部分情况下没有任何问题，而且性能最好，但是无法保证有序性
        + 使用红黑树进行性能优化可以保证有序性，且[O(logV)]与[O(1)]性能差距并不明显
        + 红黑树相对于哈希表，更加节省空间
        + 这里使用红黑树进行性能优化

    

    
    


